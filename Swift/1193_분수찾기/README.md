## 1. 분석

문제의 주어진 2차원 배열이 있을 때, 인덱스를 입력 받고 배열의 값을 출력하는 문제이다.

## 2. 접근

문제에 주어진 2차원 배열을 지그재그 순서로 진행시켜 보았을 때 분모 + 분자의 값을 기준으로 여러 층으로 나눌 수 있었다.

분모 + 분자의 값이,

2일 때(1층): 1/1

3일 때(2층): 1/2 → 2/1

4일 때(3층): 3/1 → 2/2 → 1/3

5일 때(4층): 1/4 → 2/3 → 3/2 → 4/1 과 같이 나눌 수 있다.

여기서 각각의 층의 원소는 1개, 2개, 3개로 일정하게 오른다.

이를 이용하여 코드로 구현하였다.

```swift
let x = Int(readLine()!)!

var floor = 0
var floor_end = 0

while floor_end < x {
    floor_end += floor + 1
    floor += 1
}
```

현재의 층의 원소를 저장하는 `floor`변수, 지금까지 나왔던 층의 원소 수를 모두 더한 `floor_end`변수를 선언한다.

이후 `floor_end`가 `x`보다 크거나 같아질 때까지 `while`문을 돌려 `floor_end`값과 `floor` 값을 구한다.

3층을 예를 들어 `floor_end`, `floor`를 어떻게 사용했는 지 알아보면,

1. 만약 `x`에 6이 입력되었다고 가정하자.
2. 위의 계산으로 `floor_end` = 6, `floor` = 3이 되었다.
3. 3층의 진행은 3/1 → 2/2 → 1/3 으로 된다. 각각 인덱스는 4, 5, 6이다. `x`가 6이 입력되었으므로 1/3이 출력되어야 한다.

```swift
var numerator = floor_end - x + 1
var denominator = floor + 1 - numerator
```

1. `numerator`는 위의 계산으로 1이 되며, `denominator`는 현재 층이 3층이고 분자 + 분모 = 4임을 이용해, 자동으로 3이 된다.

```swift
if floor % 2 == 0 {
    swap(&numerator, &denominator)
}
```

1. 현재 층(3층)에서는 인덱스가 증가할 수록 3/1 → 2/2 → 1/3이 되며, 이는 문제에 주어진 배열의 답과 같지만, 짝수 층에서는 3층과 마찬가지로 2/1 → 1/2나(2층), 4/1 → 3/2 → 2/3 → 1/4가(4층) 된다. 따라서 이를 문제의 배열에 맞게 바꾸기 위해 위와 같은 코드를 넣었다.
2. 만약 짝수 층이라면 `numerator`와 `denominator`의 값을 서로 바꾼다. 이렇게 되면 2층은 1/2 → 2/1, 4층은 1/4 → 2/3 → 3/2 → 4/1이 되며, 문제의 답과 일치하게 된다.
3. `numerator`와 `denominator`을 출력 형식에 맞게 출력한다.