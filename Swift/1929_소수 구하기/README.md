## 1. 분석

주어진 범위 내에 존재하는 소수들을 모두 출력하는 문제이다.

## 2. 접근

기본적인 에라토스테네스의 체 알고리즘을 이용하여 문제를 해결하였다.

편의를 위해 `n + 1`개의 `true` 원소를 가진 배열 `prime`을 만들고,

`prime[1]`은 `false`로 초기화 하였다.

이후 1부터 `n`까지 탐색을 하면서 만약 `true`라면 이전까지 어떤 수의 곱으로 이루어져 있지 않은 수(소수) 이므로, 그 수를 곱하여 나오는 수를 `false`로 바꿔주고 다음 수로 넘어간다.

이렇게 모든 수를 탐색했다면 `true`로 남아있는 수는 소수가 된다.

이때 `n`까지 탐색을 해도 좋지만, `n`을 만드는 두 수의 곱에서 두 수의 최댓값은 $\sqrt n$이므로 $\sqrt n$까지만 탐색을 하면 된다.

이후의 수는 기존 작은 수의 곱으로 이미 걸러졌을 것이기 때문이다.

위의 방법, 에라토스테네스의 체 알고리즘의 시간복잡도는 $O(n\log \log n)$이며 거의 선형시간에 해결될 정도로 빠르다.

하지만 다른 방식의 알고리즘, 예를 들어 각각의 수마다 이전의 수를 나눠보는 식의 알고리즘은 최소 $O(n\sqrt n)$이므로 시간초과가 날 가능성이 높다.

다만 어떤 특정 수가 소수임을 알고 싶을 때에도 에라토스테네스의 체 알고리즘은 사용하지 않는다. 이유는 그냥 이전의 수를 나눠보는 알고리즘의 시간복잡도가 $O(\sqrt n)$이기 때문이다.

그리고 이 알고리즘은 `n`까지의 소수를 찾고 싶다면 `n`의 크기의 배열이 필요하다는 단점이 있다. 따라서 10억 이상의 큰 수의 소수를 판별하는 데에는 사용하기 어렵다.

이렇게 큰 수의 소수 판별에는 밀러-라빈 알고리즘이 사용되며, 이 알고리즘은 어떤 수가 소수임을 **확률적으로** 판별하는 데에 드는 시간복잡도가 $O(\log ^3n)$이다.

다만 페르마의 소정리를 사용하는 이 알고리즘은 충분히 큰 확률로 소수인지 아닌지 알아내지만, 페르마의 소정리로 소수 판별이 불가능한 카마이클 수 같은 경우에는 판별이 불가능하다.